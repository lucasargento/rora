# Problem Description:
'''Problem description: A science store makes two boxes, a cheap and expensive box. The cheap box contains 3 units of metal and 5 units of acid which can be mixed to create 8 units of foam. The expensive box contains 5 units of metal and 8 units of acid which can be mixed to create 10 units of foam. The cheap box however gives off 2 units of heat while the expensive box gives off 3 units of heat. The science store has available 200 units of metal and 300 units of acid. If at most 50 units of heat can be given off, how many of each box should the store make to maximize the amount of foam produced?

Expected Output Schema:
{
  "variables": {
    "BoxesProduced": [
      "float"
    ]
  },
  "objective": "float"
}'''

# Mathematical Formulation:
'''Sets:
- B: set of box types = {cheap, expensive}

Parameters:
- metal_req[b]: units of metal required to produce one box of type b (for cheap: 3 units; for expensive: 5 units)
- acid_req[b]: units of acid required to produce one box of type b (for cheap: 5 units; for expensive: 8 units)
- foam_prod[b]: units of foam produced by one box of type b (for cheap: 8 units; for expensive: 10 units)
- heat_prod[b]: units of heat generated by one box of type b (for cheap: 2 units; for expensive: 3 units)
- metal_avail: total available units of metal = 200 units
- acid_avail: total available units of acid = 300 units
- max_heat: maximum allowed total heat = 50 units

Variables:
- x[b]: number of boxes of type b to produce [integer ≥ 0]

Objective:
- Maximize total foam produced, defined as: foam_total = foam_prod[cheap] * x[cheap] + foam_prod[expensive] * x[expensive]
  
Constraints:
1. Metal constraint: metal_req[cheap] * x[cheap] + metal_req[expensive] * x[expensive] ≤ metal_avail  
   (Interpretation: Total metal used cannot exceed 200 units)
2. Acid constraint: acid_req[cheap] * x[cheap] + acid_req[expensive] * x[expensive] ≤ acid_avail  
   (Interpretation: Total acid used cannot exceed 300 units)
3. Heat constraint: heat_prod[cheap] * x[cheap] + heat_prod[expensive] * x[expensive] ≤ max_heat  
   (Interpretation: Total heat produced cannot exceed 50 units)

Comments:
- All units are assumed consistent: metal and acid are measured in units, foam in units, heat in units.
- The decision variables x[cheap] and x[expensive] are integers since partial boxes are not allowed.
- This formulation faithfully represents the problem of maximizing foam production under resource and heat constraints.

Expected Output Schema:
{
  "variables": {
    "BoxesProduced": [
      "float"
    ]
  },
  "objective": "float"
}'''

# Generated Code:
#!/usr/bin/env python3
from ortools.linear_solver import pywraplp

def solve_with_linear_solver():
    # Create the linear solver with the CBC backend.
    solver = pywraplp.Solver.CreateSolver('CBC_MIXED_INTEGER_PROGRAMMING')
    if not solver:
        return None

    # Decision Variables: number of cheap and expensive boxes produced (integer, non-negative)
    x_cheap = solver.IntVar(0, solver.infinity(), 'x_cheap')
    x_expensive = solver.IntVar(0, solver.infinity(), 'x_expensive')

    # Parameters
    metal_avail = 200
    acid_avail = 300
    max_heat = 50

    # Requirements per box type
    metal_req_cheap = 3
    metal_req_expensive = 5
    acid_req_cheap = 5
    acid_req_expensive = 8
    foam_prod_cheap = 8
    foam_prod_expensive = 10
    heat_prod_cheap = 2
    heat_prod_expensive = 3

    # Constraints
    # Metal constraint: 3*x_cheap + 5*x_expensive <= 200
    solver.Add(metal_req_cheap * x_cheap + metal_req_expensive * x_expensive <= metal_avail)
    
    # Acid constraint: 5*x_cheap + 8*x_expensive <= 300
    solver.Add(acid_req_cheap * x_cheap + acid_req_expensive * x_expensive <= acid_avail)
    
    # Heat constraint: 2*x_cheap + 3*x_expensive <= 50
    solver.Add(heat_prod_cheap * x_cheap + heat_prod_expensive * x_expensive <= max_heat)

    # Objective: Maximize foam produced (8*x_cheap + 10*x_expensive)
    objective = solver.Objective()
    objective.SetCoefficient(x_cheap, foam_prod_cheap)
    objective.SetCoefficient(x_expensive, foam_prod_expensive)
    objective.SetMaximization()

    # Solve the problem.
    status = solver.Solve()

    result = {}
    if status == pywraplp.Solver.OPTIMAL:
        # Build the expected output schema result.
        result['variables'] = {"BoxesProduced": [x_cheap.solution_value(), x_expensive.solution_value()]}
        result['objective'] = objective.Value()
    else:
        result['error'] = "The problem does not have an optimal solution."
    return result

def main():
    # Since only one formulation is provided, we will use a single implementation using ortools.linear_solver.
    linear_solver_result = solve_with_linear_solver()

    # Display the results in a structured way.
    print("Results from Linear Solver Implementation:")
    for key, value in linear_solver_result.items():
        print(f"{key}: {value}")

if __name__ == '__main__':
    main()

'''Execution Results:
SUCCESS:
Results from Linear Solver Implementation:
variables: {'BoxesProduced': [25.0, 0.0]}
objective: 200.0
'''

'''Expected Output:
Expected solution

: {'variables': {'BoxesProduced': [25.0, 0.0]}, 'objective': 200.0}'''

